Задумывались ли вы над тем, что делают ИТ программы?

Приведите свои примеры.

Например, ИТ программы помогают управлять воздушным трафиком,
контролируют финансовые потоки (транзакции), управляют умными
светофорами на улицах.

Давайте разберём пример с программой управления умным светофором.

Как она работает?

В составе этой системы есть камеры, через которые система получает
изображение части дороги. После получения информации (входных данных)
от камер (внешние источники) система анализирует полученное изображение,
распознаёт транспортные средства и воссоздаёт дорожную ситуацию на
перекрёстке у себя в памяти (в памяти программы/компьютера). Это
пример преобразования (трансформации) данных из одного представления
в другое. В данном случае это делается для того, чтобы в дальнейшем
было удобнее анализировать эти данные.

После воссоздания дорожной ситуации в своей памяти (в определённом
формате), система запускает процесс анализа сложившейся дорожной
ситуации на перекрёстке. Этот процесс описывается алгоритмом (чёткой
последовательностью дейсвий совершаемых программой).

Результатом работы алгоритма по анализу дорожной ситуации на
перекрёстке является решение о том в какое положение надо переключить
светофор в данный момент времени. Это решение и есть конечный
результат работы компьютерной программы.

После получения решения в какое положение надо переключить светофор
система переключает светофор в нужное положение передавая команды
самому светофору.

Проанализировав систему управления умным светофором можно заметить,
что самым важным для её работы являются входные данные получаемые от
камер в виде изображения (картинки). Если данные не будут поступать,
то системе нечего будет обрабатывать и она не сможет эффективно
управлять движением на перекрёстке. Все, что она сможет делать без
данных о текущем состоянии дорожного движения на перекрёстке это
переключать светофор в другое положение через равные отрезки времени.
В таком случае умный светофор ничем не будет отличаться от светофора
без "мозгов" (компьютерной программы).

Пример с системой умного светофора показывает, что данные являются
ключевым элементом в компьютерных системах. Без данных компьютерные
системы будут просто бесполезны. Они не смогут выполнять свои задачи.
Именно поэтому разработку компьютерных систем начинают с анализа и
создания модели данных с которой будет работать компьютерная система.

Что такое модель данных компьютерной системы?

Например для системы умного светофора модель данных может выглядеть так:
цветное изображение (картинка) 100 на 100 пикселей в системе RGB.
Пикселем в ИТ называют одну ячейку изображения (более подробно про
то что такое пиксель можно прочитать более подробно тут:
https://ru.wikipedia.org/wiki/%D0%9F%D0%B8%D0%BA%D1%81%D0%B5%D0%BB%D1%8C)

В системе RGB каждый пиксель описывается тремя числами от 0 до 255 каждое.
Например: R - 10, G - 177, B - 250. Более подробно про систему RGB
можно прочитать тут: https://ru.wikipedia.org/wiki/RGB.

Исходя из приведённого выше анализа и описания мы можем разработать
чёткую модель данных, которая будет учитывать требования, формат и способ
представления данных в компьютерной программе.

Очевидно, что изображение 100 на 100 пикселей легко представить в виде
двумерного массива. Единственная проблема состоит в том, что каждый
пиксель это не просто одно число, а целых три числа в системе RGB
(каждое число это число в диапазоне от 0 до 255). Три числа в одну
ячейку массива не положишь.

Перед тем как читать дальше, подумайте как бы вы решили эту задачу?
Как бы вы представили изображение в системе RGB 100 на 100 пикселей
в компьютерной программе?

Для решения этой задачи можно воспользоваться принципами ООП
(объектно ориентированного программирования). Можно создать класс
Pixel, который будет описывать один пиксель в изображении:

class Pixel {

    private int red;
    private int green;
    private int blue;

    Pixel(int red, int green, int blue) {
        this.red = red;
        this.green = green;
        this.blue = blue;
    }

    int getRed() {return this.red;}
    int getGreen() {return this.green;}
    int getBlue() {return this.blue;}

}

setX() методы в нашем случае будут не нужны, так как после создания
изображения (которое состоит из матрицы пикселей) программа умного
светофора не будет менять изображение, а значит и не будет менять
значения у конкретных экземпляров класса Pixel. Поэтому setX()
методы в нашей модели не нужны. В компьютерных программах лучше
не создавать лишние элементы (те которые не нужны в данный момент),
они в коде будут только мешать.

Создав класс Pixel мы можем чётко описать изображение получаемое
системой умного светофора с камер:
    Pixel[][] picture = new Pixel[100][100];
- изображение это двумерный массив в каждой ячейке которого лежит
объект класса Pixel. Это и есть детально проработанная модель данных
получаемая системой умного светофора от камер. В этой модели чётко
описан формат и представление изображения. На основе данной модели
можно строить дальнейшую обработку данных и их анализ, тоесть
разрабатывать внутренние алгоритмы программы.

Без чёткой и конкретной модели данных тяжело разрабатывать приложение,
сложно писать код, так как не понятно какие данные и в каков формате/виде
будут поступать на вход приложению или его части, и что эта часть
приложения должна выдавать в качестве результата. Если у вас нет чётко
проработанной модели данных для приложения, то начинать писать код
не имеет большого смысла. Начните с анализа предметной области вашего
приложения и разработки модели данных.

Что такое анализ предметной области для приложения?

Анализ предметной области для приложения это в первую очередь чёткое
понимание всех бизнес процессов, что каждый из них делает и зачем,
какова их цель и какую ценность они представляют для бизнеса. Нужно
понять, с какой целью бизнес хочет автоматизировать тот или иной
бизнес процесс по средством компьютерной программы. Что это даст
бизнесу, как автоматизация конкретного бизнес процесса повлияет
на другие бизнес процессы?

Анализируя каждый из бизнес процессов отдельно выявляйте и записывайте
с какой информацией этот процесс имеет дело, какими данными оперирует,
какая информация/данные нужны этому бизнес процессу для выполнения
своей задачи. Определите какая информация (данные) важна для данного
бизнес процесса, а какая нет.

Например для системы умного светофора не важен цвет машины, но важен
сам факт ее появления у перекрёстка, не важен номерной знак транспортного
средства, но важен его размер (сколько места занимает транспортное
средство в очереди ожидания перед перекрёстком). А вот для системы
регистрации транспортных средств важны и номер машины и цвет транспортного
средства.

Вывод: для каждой из систем важны свои свойства и характеристики,
свои информация и данные которые будут иметь значение в рамках конкретной
системы и влиять на её поведение.

После выявления для конкретной системы или бизнес процесса релевантной
информации нужно чётко определить в каком виде она будет представлена
в компьютерной системе. Для этого в языке программирования Java
используют типы данных, переменные, классы и объекты, а так же
параметры методов и возвращаемый результат.


Модель данных нужно придумать/разработать/создать как для тех данных,
которые будут поступать в программу извне (тоесть для входных данных),
так и для представления данных внутри самой программы.

Для примера давайте попробуем вместе разработать модель данных для
электронной копилки. Пусть электронная копилка будет простой копилкой
у которой с внешней стороны есть дисплей, который всегда показывает
сколько денег находится в копилке. В такую копилку можно опускать
только монеты номиналом 1, 2, 5, 10, 20, 50 центов, 1 и 2 евро. При
опускании монеты в копилку специальный сенсор определяет номинал
монеты опускаемой в копилку и подаёт его на вход системе электронной
копилки.

Первый вопрос: как в программе представить монеты (1, 2 ... центы
и 1, 2 евро)?

Перед тем как вы продолжите читать дальше, попробуйте придумать
свой ответ на поставленный вопрос. Вы сможете сравнить ваш
ответ с тем, который будет описан далее.

Тут можно придумать много решений:
- две переменные: int - цифра, String - "цент"/"евро";
- enum со значениями: ONE_CENT, TWO_CENT, и так далее;
- класс Coin.

Давайте рассмотрим последний вариант с классом Coin.

У монеты есть две характеристики имеющие значение для системы
электронной копилки: число указанное на монете и название (евро или цент).
Только эти две характеристики влияют на общую сумму денег хранящуюся
в электронной копилке, именно эти два свойства будут в дальнейшем
иметь значение и использоваться при расчёте суммы денег в копилке.
Например характеристика (свойство) вес монеты или её цвет не имеют
никакого значения. Вес и цвет монеты имеют значение для системы
сканера распознающего какую монету бросают в копилку.

Так как мы определили, что для нашей системы имеют значение номинал
(число) и название монеты (цент/евро) то давайте подумаем как можно
представить эти свойства в компьютерной программе? При помощи
каких типов данных можно описать эти свойства? Номинал (число) является
целым числом, а в языке программирования Java целое число описывается
типом данных int. Название монеты (цент/евро) - это строка/текст, в
языке программирования Java текст описывается типом данных String.

С типами данных определились. Теперь давайте опишем класс Coin
с двумя свойствами:

class Coin {

    private int denomination;
    private String title;

    public Coin(int denomination, String title) {
        this.denomination = denomination;
        this.title = title;
    }

}

Теперь становится ясно, что сканер распознаёт монету опускаемую
в копилку, создаёт экземпляр класса Coin и подаёт его на вход системе
электронной копилки для дальнейшего подсчёта суммы.

Как представлена сумма денег хранящаяся в копилке в системе электронной
копилки (программе)? Попробуйте придумать два варианта.

Сумму денег хранящуюся в копилке можно представить и хранить как
целое число представляющее собой центы, при добавлении новой монеты
в копилку прибавлять к этому числу номинал монеты в центах.

Второй способ, как можно пердставить сумму денег в копилке основан
на том, что сама сумма это расчитываемое значение. Она расчитывается
суммируя все номиналы монет в центах ханящиеся в копилке. Тоесть
для расчёта суммы денег в копилке не обязательно хранить саму сумму
как число. Достаточно хранить сами монеты и тогда программа сможет
в любой момент времени посчитать сумму денег в копилке. Тоесть
сама сумма денег это производная (то что можно расчитать основываясь
на других данных) от монет лежащих в копилке. Поэтому программа может
при добавлении монеты (экземпляра класса Coin) в копилку сохранять
этот экземпляр например в массив:
    Coin[] coins = new Coin[coinCapacity];
    // coinCapacity - число монет помещающихся в копилку (вместимость)
Имея такой массив с сохранёнными монетами не сложно написать метод
для расчёта суммы денег в копилке:
    public int calculateAmountOfMoney() {

    }

Попробуем реализовать оба предложенных выше варианта.

В первом варианте электронная копилка просто хранит общую сумму денег
в копилке. В этом случае система не запоминает какие монеты были
брошены в копилку, запоминает только общую сумму и сможет показать
ее например на внешнем электронном табло копилки.

Исходя из рассуждений приведённых выше, можно разработать следующий
класс представляющий электронную систему корилки:

class PiggyBankV1 {

    private int amountOfMoneyInCents;

    public PiggyBankV1() {
        this.amountOfMoneyInCents = 0;
    }

    public void addCoin(Coin coin) {
        // допишите логику тут
    }

    public int getAmountOfMoneyInCents() {
        return this.amountOfMoneyInCents;
    }

}

Копилка создаётся всегда пустой, поэтому в конструкторе
this.amountOfMoneyInCents = 0.

Реализуйте логику в методе addCoin(). Этот метод вызывается при
добавлении новой монеты в копилку (Coin coin). При реализации
учтите тот факт, что монеты бывают разные (евро и центы). Алгоритм
внутри метода addCoin() должен добавлять соответствующее количество
центов к свойству amountOfMoneyInCents класса PiggyBankV1.

Напишите тесты для класса PiggyBankV1. Протестируйте добавление
в копилку монет разного номинала: 1,2,5,10,20,50 центов и 1,2 евро.


Реализуйте второй вариант системы электронной копилки основанный на
массиве (Coin[] coins = new Coin[coinCapacity];). Для этого создайте
класс PiggyBankV2 следующим образом:

class PiggyBankV2 {

    private Coin[] coins;

    public PiggyBankV2(int coinCapacity) {
        this.coins = new Coin[coinCapacity];
    }

    public void addCoin(Coin coin) {
        // допишите логику тут
    }

    public int getAmountOfMoneyInCents() {
        //
    }

}

Копилка создаётся определённой вместимости, параметр coinCapacity
показывает сколько монет может поместиться в копилку.

Реализуйте логику в методе addCoin(). В данной реализации метод
addCoin() должен сохранять новую монету в свободную ячейку массива.
Что делать если все ячейки заняты? Попробуйте самостоятельно придумать
и реализовать ответ на этот вопрос.

Реализуйте логику в методе getAmountOfMoneyInCents(). Идея алгоритма
заключается в прохождении по массиву и расчёту суммы номиналов всех
монет.

Примените тесты написанные для класса PiggyBankV1 к классу PiggyBankV2.
Если вы реализовали все правильно то они должны проходить. Если вы
придумали дополнительную логику по обработке переполнения в копилке
(когда для новой монеты нет места в копилке), то напишите дополнительные
тесты для проверки этой логики.

